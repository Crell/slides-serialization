<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Serializing PHP</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <!--  <link rel="stylesheet" href="dist/theme/black.css" id="theme">-->

  <link rel="stylesheet" href="platform/platformsh.css" id="theme" />

  <!-- Theme used for syntax highlighted code -->
  <link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">

  <style>

  </style>

</head>
<body class="skin-blue">
<div class="reveal">
  <footer>
    <img src="assets/lz-logo-black.svg" alt="LegalZoom" />
    <span class="name">@Crell@phpc.social</span>
  </footer>
	<div class="slides">
    <section class="title">
      <h1>Serializing PHP</h1>
    </section>

    <section id="presenter">
      <h2>Larry Garfield</h2>
      <h2><a href="https://phpc.social/@Crell">@Crell@phpc.social</a></h2>

      <div class="layout-col vcentered">
        <a href="http://bit.ly/php80"><img src="assets/exploring-php80.png" width="175px;" alt="Cover of Exploring PHP 8.0" /></a>
        <a href="https://bit.ly/fn-php"><img src="assets/thinking-functionally.png" width="175px;" alt="Cover of Thinking Functionally in PHP" /></a>

        <ul style="text-wrap: none">
          <li style="margin-top: 1em;">Staff Engineer for <a href="https://www.typo3.com/">LegalZoom</a></li>
          <li style="margin-top: 1em;">PHP-FIG Core Committee</li>
          <li style="margin-top: 1em;">General purpose pedant</li>
          <li style="margin-top: 1em;"><a href="http://bit.ly/php80"><em>Exploring PHP 8.0</em></a></li>
          <li style="margin-top: 1em;"><a href="https://bit.ly/fn-php"><em>Thinking Functionally in PHP</em></a></li>
        </ul>
      </div>
    </section>

    <section>
      <section>
        <h2>What is serialization?</h2>
      </section>
      <section data-background="assets/cereal-bowl.jpg" data-credit="https://flickr.com/photos/cottinghamphotography/6200250080/">
        <h2>Cerealization</h2>
        <p class="fullscreen-credit">(Credit: <a href="https://flickr.com/photos/cottinghamphotography/6200250080/">https://flickr.com/photos/cottinghamphotography/6200250080/</a>)</p>
        <aside class="notes">
          <ul>
            <li>The process of putting cornflakes in milk.</li>
          </ul>
        </aside>
      </section>
      <section>
        <aside class="quote">
          <blockquote>In computing, serialization... is the process of translating a data structure or object
            state into a format that can be <em>stored</em> (e.g. files in secondary storage devices, data buffers in
            primary storage devices) or <em>transmitted</em> (e.g. data streams over computer networks) and
            <em>reconstructed</em> later (possibly in a different computer environment).</blockquote>
          <blockquote class="fragment">For many complex objects, such as those that make extensive use of references,
            this process is <em>not straightforward</em>.</blockquote>
          <cite><a href="https://en.wikipedia.org/wiki/Serializationl">Wikipedia</a></cite>
        </aside>
        <aside class="notes">
          <ul>
            <li>Moving data into and out of the application.</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>Story time</h2>
        <p><img src="assets/typo3.svg" alt="TYPO3" style="width: 400px"></p>
        <aside class="notes">
          <ul>
            <li>In 2021, worked at TYPO3</li>
            <li>Turn massive config array into objects</li>
            <li>20+ year old config structure, never refactored for BC reasons</li>
            <li>Needed to change structure on import</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Requirements</h2>
        <ul>
          <li class="fragment">Mutate data on import</li>
          <li class="fragment">Dynamic type maps</li>
          <li class="fragment">Implode/explode arrays, sometimes</li>
          <li class="fragment">Fast</li>
        </ul>
        <p class="fragment"><q>Don't solve a problem, build a tool to solve the problem, then use it.</q></p>
        <aside class="notes">
          <ul>
            <li>Type maps = Nested object that could be different types</li>
            <li>Sounds like a special case of serialization!</li>
            <li>This is how I got interested in serialization</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>So, Symfony Serializer?</h2>
        <ul>
          <li class="fragment" style="list-style-type: '+'">Widely used</li>
          <li class="fragment" style="list-style-type: '+'">Very flexible</li>
          <li class="fragment" style="list-style-type: '-'">Couldn't collect/flatten</li>
          <li class="fragment" style="list-style-type: '-'">Only static type maps ("class discriminators")</li>
          <li class="fragment" style="list-style-type: '-'">Complex architecture, hard to modify</li>
        </ul>
        <p class="fragment">Sigh.  Time to write one...</p>
        <aside class="notes">
          <ul>
            <li>2 weeks trying to make it work</li>
            <li>Became clear it couldn't do what I wanted</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>Plethora of Potential PHP Processes</h2>
        <ul>
          <li class="fragment"><code>__sleep</code>/<code>__wakeup</code> (The before times)</li>
          <li class="fragment"><code>Serializable</code> (PHP 5.1, Deprecated in 8.1)</li>
          <li class="fragment"><code>__serialize</code>/<code>__unserialize</code> (PHP 7.4)</li>
          <li class="fragment"><code>var_export()</code>/<code>__set_state()</code></li>
          <li class="fragment"><code>JsonSerializable</code> (<code>__serialize()</code> only, for <code>json_encode()</code>)</li>
          <li class="fragment">Roll your own...</li>
        </ul>
      </section>
      <section>
        <h3><code>__serialize</code>/<code>__unserialize</code> (PHP 7.4)</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers="|8-10|12-16">
          class User {
              protected int $id;
              protected string $name;
              protected DateTime $lastLogin;

              // ...

              public function __serialize(): array {
                  return ['id' => $this->id, 'name' => $this->name];
              }

              public function __unserialize(array $data): void {
                  $this->id = $data['id'];
                  $this->name = $data['name'];
                  $this->lastLogin = UserSystem::getLastLogin($this->id);
              }
          }
        </code></pre>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          $s = serialize(new User());
          print_r($s);

          $u = unserialize($s);

          // O:4:"User":2:{s:2:"id";i:42;s:4:"name";s:5:"Larry";}
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Note: Handling is intrinsic to the class.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3><code>var_export()</code>/<code>__set_state()</code> (PHP 4.2)</h3>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          class User {
              protected int $id;
              protected string $name;
              protected DateTime $lastLogin;

              public static function __set_state(array $data): self {
                  $new = new self();
                  $new->id = $data['id'];
                  $new->name = $data['name'];
                  $new->lastLogin = UserSystem::getLastLogin($this->id);
                  return $new;
              }
          }
        </code></pre>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          $s = var_export(new User(), true);
          file_put_contents('export.php', "&lt;?php return $s;");
          $u = require('export.php');
        </code></pre>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          &lt;?php return User::__set_state(array(
             'id' => 5,
             'name' => 'Crell',
             'lastLogin' =>
            DateTime::__set_state(array(
               'date' => '2023-08-22 21:26:52.441708',
               'timezone_type' => 3,
               'timezone' => 'Europe/Amsterdam',
            )),
          ))
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Can only control the deserialization side</li>
            <li>Deserialization requires custom user-space code</li>
            <li>Objects are all opt-in (need <code>__set_state()</code>)</li>
            <li>Doesn't actually work on DateTime!</li>
            <li>Fine for arrays, but worth it for objects?</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Which is better?</h2>
        <div class="fragment oversize">
          <p>Quick, to the benchmark mobile!</p>
          <p>cf: <a href="https://peakd.com/hive-168588/@crell/benchmarking-serialization">Benchmarking Serialization</a></p>
        </div>
        <aside class="notes">
          <ul>
            <li>Expected __set_state() to be fastest, if more work.</li>
            <li>Trust, but verify!</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2><code>unserialize()</code> vs <code>__set_state()</code></h2>
        <p><img src="assets/benchmark-results-web-zoomed.png" alt="__set_state() is faster at low cardinality"></p>
        <p class="fragment"><code>__set_state()</code> wins! ...By 1.25 ms over 4000 objects</p>
        <aside class="notes">
          <ul>
            <li>Around 5000 items, hit opcache file limit, then it was horrible.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Conclusions</h2>
        <div><code>__set_state()</code> is faster than <code>unserialize()</code>
          <div class="fragment">by a very slim margin</div>
          <div class="fragment">under very specific conditions</div>
          <div class="fragment">and requires a lot more work.</div>
        </div>
        <br />
        <p class="fragment">Exporting objects to code is almost never worth it. <code>unserialize()</code> is very fast.</p>
        <aside class="notes">
          <ul>
            <li>1.25 ms over 4000 objects</li>
            <li>Beware of opcache size</li>
            <li>Lots of extra work for very little gain</li>
            <li>var_export() still OK for arrays, just not objects</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>But what about outside systems?</h2>
        <aside class="notes">
          <ul>
            <li>JSON, YAML, XML, TOML, etc.</li>
            <li>Gotta roll your own</li>
            <li>What makes for good serialization hygene?</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Separate Logic from Data</h2>
        <div>
          <div style="float: left;"><img src="assets/spock.jpg" alt="Logic" style="max-height: 400px;" /></div>
          <div style="float: right;"><img src="assets/data.jpg" alt="Data"  style="max-height: 400px;" /></div>
        </div>
      </section>
      <section>
        <h2>Separate logic from data</h2>
        <ul>
          <li class="fragment">If it's in your DI Container, thou shalt not serialize it</li>
          <li class="fragment">If it references something in the container, thou shalt not serialize</li>
          <li class="fragment">Value objects: +1</li>
          <li class="fragment">Entities: Only in data mapper</li>
          <li class="fragment">Just say <em>No</em> to Active Record</li>
          <li class="fragment">Applies to all serialization formats</li>
        </ul>
        <p class="fragment">These are all good practices anyway.</p>
        <aside class="notes">
          <ul>
            <li>All alternatives suck, involve globals</li>
            <li>Applies to serialize()/var_export(), too.</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h2>Simple hydration</h2>
        <h2 class="fragment"><a href="https://github.com/Crell/EnvMapper">EnvMapper</a></h2>
        <aside class="notes">
          <ul>
            <li>Many of these on GitHub</li>
            <li>Built this afterward</li>
            <li>Just to show concept</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>The core logic (1)</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers="|3|4-5|8,19|11-13|14-15">
          class EnvMapper {
              public function map(string $class, bool $require = false, ?array $source = null): object {
                  $source ??= $_ENV;
                  $rClass = new \ReflectionClass($class);
                  $rProperties = $rClass->getProperties();

                  $toSet = [];
                  foreach ($rProperties as $rProp) {
                      $propName = $rProp->getName();
                      $envName = $this->normalizeName($propName);
                      if (isset($source[$envName])) {
                          $toSet[$propName]
                            = $this->typeNormalize($source[$envName], $rProp);
                      } elseif (PropValue::None !== $default = $this->getDefaultValue($rProp)) {
                          $toSet[$propName] = $default;
                      } elseif ($require) {
                          throw MissingEnvValue::create($propName, $class);
                      }
                  }

                  // ...
              }
           }
        </code></pre>
      </section>
      <section>
        <h2>The core logic (2)</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          class EnvMapper {
              public function map(string $class, bool $require = false, ?array $source = null): object {
                  // ...

                  $populator = function (array $props) {
                      foreach ($props as $k => $v) {
                          try {
                              $this->$k = $v;
                          } catch (\TypeError $e) {
                              throw TypeMismatch::create($this::class, $k, $v);
                          }
                      }
                  };

                  $env = $rClass->newInstanceWithoutConstructor();

                  $populator->call($env, $toSet);

                  return $env;
              }
           }
        </code></pre>
      </section>
      <section>
        <h2>What does this show?</h2>
        <ul>
          <li class="fragment">Deserialization is driven by class definition</li>
          <li class="fragment">Type info & defaults driven by class definition</li>
          <li class="fragment">Reflection is pretty fast, but not free</li>
        </ul>
        <p class="fragment oversize">These will be important</p>
      </section>
      <section>
        <h2>Cool PHP trick #1</h2>
        <h3>Visibility busting</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
           $reader = (fn (string $prop) => $this->$prop ?? null)->bindTo($obj, $obj);

          $value = $reader('privateProp');
        </code></pre>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          $populator = function (array $props) {
              foreach ($props as $k => $v) {
                  $this->$k = $v;
              }
          };

          $env = $rClass->newInstanceWithoutConstructor();

          $populator->call($obj, $toSet);
        </code></pre>
        <p class="fragment">(Please don't do this)</p>
      </section>
      <section>
        <h2>Cool PHP trick #2</h2>
        <h3>Enum as error code</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          enum PropValue {
              case None;
          }

          // This specific case is mixed, but usually union types are better.
          function getDefaultValue(\ReflectionProperty $subject): string|PropValue
          {
              $params = $this->getPropertiesForClass($subject->getDeclaringClass());

              $param = $params[$subject->getName()] ?? null;

              return $param?->isDefaultValueAvailable()
                  ? $param->getDefaultValue()
                  : PropValue::None;
          }
        </code></pre>
        <p class="fragment">cf: <a href="https://peakd.com/hive-168588/@crell/much-ado-about-null">Much Ado about Null</a></p>
      </section>
    </section>
    <section>
      <section>
        <h2>Roll your own</h2>
        <div class="fragment">
          <p class="oversize">Stand on the shoulders of giants</p>
          <img src="assets/rust-logo.svg" alt="I studied the Rust Serde crate">
        </div>
        <aside class="notes">
          <ul>
            <li>Studied Rust Serde crate</li>
            <li>Almost universally loved, so worth cribbing</li>
            <li>End result takes inspiration, but is not a direct port</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Three libraries</h2>
        <ul>
          <li><a href="http://github.com/Crell/fp">Crell/fp</a></li>
          <li><a href="http://github.com/Crell/AttributeUtils">Crell/AttributeUtils</a></li>
          <li><a href="http://github.com/Crell/Serde">Crell/Serde</a></li>
        </ul>
        <aside class="notes">
          <ul>
            <li>Won't talk about fp</li>
            <li>Only talk briefly about AttributeUtils</li>
            <li>Will talk mostly about Serde</li>
            <li>All built to assume PHP 8.1, started work in the betas</li>
          </ul>
        </aside>
      </section>
    </section>
    <section>
      <section>
        <h3>Attributes overview</h3>
        <pre><code class="php font--20" data-trim data-noescape data-line-numbers>
          #[GreedyLoad(type: 'all')]
          class Product
          {
              #[Positive, NonZero]
              protected int $id;

              #[Permission(perm: new Pemission('read'), type: Perms::Basic]
              public function refillStock(int $quantity): bool
              {
                  // ...
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>No intrinsic meaning; only available in Reflection</li>
            <li>Attributes are strings or classes</li>
            <li>Basically a constructor call. Named args recommended.</li>
            <li>Prop values can be objects and enums</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Limitations</h2>
        <ul>
          <li class="fragment">Reflection API is clumsy</li>
          <li class="fragment">No access to the structure the attribute was on</li>
          <li class="fragment">No inheritance</li>
          <li class="fragment">No way to group related attributes</li>
          <li class="fragment">No built-in default handling</li>
          <li class="fragment">Attributes cannot be contextual</li>
        </ul>
        <p class="fragment oversize">AttributeUtils addresses all of those</p>
      </section>
      <section>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers="|2,6-8|2,10-12">
          #[\Attribute(\Attribute::TARGET_CLASS)]
          class Data implements FromReflectionClass, ParseProperties {
              public readonly string $name;
              public readonly array $properties;

              public function fromReflection(\ReflectionClass $subject): void {
                  $this->name ??= $subject->getShortName();
              }

              public function propertyAttribute(): string { return MyProperty::class; }
              public function includePropertiesByDefault(): bool { return true; }
              public function setProperties(array $props): void { $this->properties = $props; }
          }

          #[\Attribute(\Attribute::TARGET_PROPERTY)]
          class MyProperty
          {
              public function __construct(
                  public readonly string $column = '',
              ) {}
          }
        </code></pre>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          #[Data]
          class Record {
              #[MyProperty(column: 'beep')]
              protected property $foo;

              private property $bar;
          }
          $dataAttrib = $analyzer->analyze(Record::class, Data::class);
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Read "analyze Record with respect to Data"</li>
            <li>All interface-driven opt-in</li>
            <li>Save off bits of reflection if you want</li>
            <li>$dataAttrib is an instance of Data, with a 2 element array of MyProperty</li>
            <li>Note: Public readonly props.  Optional, recommended.</li>
            <li>Similar Parse* interfaces for other parts of a class</li>
            <li>Similar FromReflection* for other parts of a class</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Inheritance is opt-in</h3>
        <pre><code class="php font--20" data-trim data-noescape data-line-numbers>
          #[\Attribute(\Attribute::TARGET_CLASS)]
          class Person implements Inheritable
          {
              public function __construct(public string $name = '') {}
          }

          #[Person(name: 'Jorge')]
          class A {}

          class B extends A {}

          $attrib = $analyzer->analyze(B::class, Person::class);

          print $attrib->name . PHP_EOL; // prints Jorge
        </code></pre>
        <p class="fragment oversize">Analyzer does <code>instanceof</code>,<br />so child attributes work, too</p>
      </section>
      <section>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          #[\Attribute(\Attribute::TARGET_CLASS)]
          class MainAttrib implements HasSubAttributes {
              public readonly int $age;

              public function __construct(public readonly string name = 'none') {}

              public function subAttributes(): array {
                  return [Age::class => 'fromAge'];
              }

              public function fromAge(?Age $sub): void {
                  $this->age = $sub?->age ?? 0;
              }
          }

          #[\Attribute(\Attribute::TARGET_CLASS)]
          class Age {
              public function __construct(public readonly int $age = 0) {}
          }
        </code></pre>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          #[MainAttrib(name: 'Larry'), Age(21)]
          class A {}

          class B {}

          $attribA = $analyzer->analyze(A::class, MainAttrib::class);
          print "$attribA->name, $attribA->age\n"; // prints "Larry, 21"

          $attribB = $analyzer->analyze(B::class, MainAttrib::class);
          print "$attribB->name, $attribB->age\n"; // prints "none, 0"
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Sub-attribute "absorbed" into main attribute</li>
            <li>Save the whole attribute or not, your choice</li>
            <li>Static analysis tools are wrong about readonly outside constructor</li>
          </ul>
        </aside>
      </section>
      <section>
        <p class="oversize">Almost all of Crell/Serde is driven by Attributes,<br />via AttributeUtils</p>
        <p class="oversize">Use it in your project today</p>
      </section>
    </section>
    <section>
      <section>
        <h2>What does Serde do?</h2>
      </section>
      <section>
        <h2>Serde</h2>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
        use Crell\Serde\SerdeCommon;

        $serde = new SerdeCommon();

        $object = new SomeClass('a', 'b', new OtherClass());

        $json = $serde->serialize($object, format: 'json');

        $obj = $serde->deserialize($json, from: 'json', to: SomeClass::class);
        </code></pre>
        <ul>
          <li class="fragment">JSON, YAML, array, CSV, streaming JSON, streaming CSV</li>
          <li class="fragment">Customize per-object-type</li>
          <li class="fragment">Customize any type</li>
          <li class="fragment">Support any additional formats</li>
        </ul>
      </section>
      <section>
        <h2>Basic usage</h2>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          class Person
          {
              #[Field(serializedName: 'callme')]
              public string $firstName = 'Larry';

              #[Field(renameWith: Cases::CamelCase)]
              public string $lastName = 'Garfield';

              #[Field(renameWith: new Prefix('online_')]
              public string $alias = 'Crell';
          }
        </code></pre>
        <pre><code class="json font--18" data-trim data-noescape data-line-numbers>
          {
            "callme": "Larry",
            "LastName": "Garfield",
            "online_alias": "Crell"
          }
        </code></pre>
        <ul>
          <li class="fragment"><code>#[Field]</code> controls behavior of a property</li>
          <li class="fragment">Can rename to a literal or via rules</li>
          <li class="fragment"><code>Cases</code> enum implements interface</li>
        </ul>
      </section>
      <section>
        <h2>Cool PHP trick #3</h2>
        <h3>Enums as default objects</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          interface RenamingStrategy {
              public function convert(string $name): string;
          }

          enum Cases implements RenamingStrategy {
              case UPPERCASE;
              case lowercase;
              case snake_case;
              case kebab_case;
              case CamelCase;
              case lowerCamelCase;

              public function convert(string $name): string {
                  return match ($this) {
                      self::UPPERCASE => strtoupper($name),
                      self::lowercase => strtolower($name),
                      self::snake_case =>  // ...,
                      self::kebab_case => // ...,
                      self::CamelCase => // ...,
                      self::lowerCamelCase => // ...,
                  };
              }
        </code></pre>
      </section>
      <section>
        <h3>Default handling</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          class Person
          {
              #[Field(default: 'Hidden')]
              public string $location;

              #[Field[(useDefault: false)]
              public int $age;

              #[Field(requireValue: true)]
              public string $job;

              public function __construct(
                  public string $name = 'Anonymous',
              ) {}
          }
        </code></pre>
        <ul class="fragment">
          <li><code>location</code> -> "Hidden"</li>
          <li><code>name</code> -> "Anonymous"</li>
          <li><code>age</code> -> uninitialized</li>
          <li><code>job</code> -> Exception</li>
        </ul>
      </section>
      <section>
        <h2>Sequences vs Dictionaries</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          class Order {
              public string $orderId;

              public int $userId;

              #[Field(serializedName: 'items')]
              #[SequenceField(arrayType: Product::class)]
              public array $products;

              #[DictionaryField(arrayType: Tag::class, keyType: KeyType::String)]
              public array $tags;
          }
        </code></pre>
        <pre><code class="json font--16" data-trim data-noescape data-line-numbers>
          {
              "orderId": "abc123",
              "userId": 5,
              "items": [
                  { "name": "Widget", "price": 9.99 },
                  { "name": "Gadget", "price": 4.99 }
              ],
              "tags": {
                "userClass": {"name": "VIP"},
                "discount": {"name": "Closeout"}
              }
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>"Arrays" are PHP's original sin</li>
            <li>SequenceField/DictionaryField are sub-attributes</li>
            <li>KeyType is enum</li>
            <li>arrayType required for array-of-objects</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Implosion</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          class Order {
              #[SequenceField(implodeOn: ',')]
              protected array $productIds = [5, 6, 7];

              #[DictionaryField(implodeOn: ',', joinOn: '=')]
              protected array $dimensions = [
                  'height' => 40,
                  'width' => 20,
              ];
          }
        </code></pre>
        <pre><code class="json font--16" data-trim data-noescape data-line-numbers>
          {
              "productIds": "5,6,7",
              "dimensions": "height=40,width=20"
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Fully round-trips!</li>
            <li>Auto-trims whitespace, can opt out</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Flatten/collect</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers="|3-4">
          class Results {
            public function __construct(
              #[Serde\Field(flatten: true)]
              public Pagination $pagination,
              #[Serde\SequenceField(arrayType: Product::class)]
              public array $products,
            ) {}
          }

          class Pagination {
            public function __construct(public int $total, public int $offset, public int $limit) {}
          }

          class Product {
            public function __construct(public string $name, public float $price) {}
          }
        </code></pre>
        <pre><code class="json font--16" data-trim data-noescape data-line-numbers>
          {
              "total": 100,
              "offset": 20,
              "limit": 10,
              "products": [
                  { "name": "Widget", "price": 9.99 },
                  { "name": "Gadget", "price": 4.99 }
              ]
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Structure in PHP different from JSON</li>
            <li>Pagination object gets "flattened", properties inlined</li>
            <li>Symmetrical. "Collect" on deserialize.</li>
            <li>Rust Serde can do this</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Advanced flattening</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers="|3-6|17-18">
        class DetailedResults {
            public function __construct(
                #[Serde\Field(flatten: true)]
                public NestedPagination $pagination,
                #[Serde\Field(flatten: true)]
                public ProductType $type,
                #[Serde\SequenceField(arrayType: Product::class)]
                public array $products,
                #[Serde\Field(flatten: true)]
                public array $other = [],
            ) {}
        }
        class NestedPagination {
            public function __construct(
                public int $total,
                public int $limit,
                #[Serde\Field(flatten: true)]
                public PaginationState $state,
            ) {}
        }
        </code></pre>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
        class PaginationState {
            public function __construct(public int $offset) {}
        }
        class ProductType {
            public function __construct(public string $name = '', public string $category = '') {}
        }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Two flattened properties</li>
            <li>Extra "stuff" flattened/collected from array property</li>
            <li>Nested objects can flatten recursively</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Advanced flattening</h3>
        <pre><code class="json font--16" data-trim data-noescape data-line-numbers>
          {
            "total": 100,
            "limit": 10,
            "offset": 20,
            "products": [
                {
                    "name": "Widget",
                    "price": 9.99
                },
                {
                    "name": "Gadget",
                    "price": 4.99
                }
            ],
            "foo": "beep",
            "bar": "boop"
        }
        </code></pre>
      </section>
      <section>
        <h2>Type Maps</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          interface Product {}

          interface Book extends Product {}

          class PaperBook implements Book {
              protected string $title;
              protected int $pages;
          }

          class DigitalBook implements Book {
              protected string $title;
              protected int $bytes;
          }

          class Sale {
              protected Book $book;
              protected float $discountRate;
          }

          class Order {
              protected string $orderId;

              #[SequenceField(arrayType: Book::class)]
              protected array $products;
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>How do we know what type of Book to deserialize to?</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Type Maps</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          class Sale {
              #[ClassNameTypeMap(key: 'type')]
              protected Book $book;

              protected float $discountRate;
          }
        </code></pre>
        <pre><code class="json font--16" data-trim data-noescape data-line-numbers>
          {
              "book": {
                  "type": "Your\\App\\DigitalBook",
                  "title": "Thinking Functionally in PHP",
                  "bytes": 45000
              },
              "discountRate": 0.2
          }
        </code></pre>
      </section>
      <section>
        <h2>Type Maps</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          class Sale {
              #[StaticTypeMap(key: 'type', map: [
                  'paper' => Book::class,
                  'ebook' => DigitalBook::class,
              ])]
              protected Book $book;

              protected float $discountRate;
          }
        </code></pre>
        <pre class="fragment"><code class="php font--16" data-trim data-noescape data-line-numbers>
          #[StaticTypeMap(key: 'type', map: [
              'paper' => Book::class,
              'ebook' => DigitalBook::class,
          ])]
          interface Book {}
        </code></pre>
        <pre><code class="json font--16" data-trim data-noescape data-line-numbers>
          {
              "book": {
                  "type": "ebook",
                  "title": "Thinking Functionally in PHP",
                  "bytes": 45000
              },
              "discountRate": 0.2
          }
        </code></pre>
      </section>
      <section>
        <h2>Dynamic Type Maps</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers="|8-14|17-21">
          class ProductTypeMap implements TypeMap {
              public function __construct(protected readonly Connection $db) {}

              public function keyField(): string {
                  return 'type';
              }

              public function findClass(string $id): ?string {
                  return $this->db->someLookup($id);
              }

              public function findIdentifier(string $class): ?string {
                  return $this->db->someMappingLogic($class);
              }
          }

          $typeMap = new ProductTypeMap($dbConnection);

          $serde = new SerdeCommon(typeMaps: [
              Your\App\Product::class => $typeMap,
          ]);

          $json = $serde->serialize($aBook, to: 'json');
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Base map on user configuration</li>
            <li>Symfony Serializer could not do this</li>
            <li>Unclear if even Rust Serde can do this</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Streaming</h2>
        <ul>
          <li class="fragment">Can stream to JSON or CSV</li>
          <li class="fragment"><code>\Traversable</code> objects treated as any other object</li>
          <li class="fragment"><code>iterable</code> will get "run out" when serializing</li>
          <li class="fragment">Result: Lazy create and lazy stream at once!</li>
        </ul>
      </section>
      <section>
        <h2>Streaming</h2>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          // The JsonStreamFormatter is not included by default.
          $s = new SerdeCommon(formatters: [new JsonStreamFormatter()]);

          // You may use any PHP supported stream here, including files,
          // network sockets, stdout, an in-memory temp stream, etc.
          $init = new FormatterStream(fopen('/tmp/output.json', 'wb'));

          $result = $serde->serialize($data, format: 'json-stream', init: $init);

          $fp = $result->stream;
          // Now do with $fp as you wish.
        </code></pre>
      </section>
      <section>
        <h2>Streaming</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          class ProductList {
              public function __construct(
                  #[SequenceField(arrayType: Product::class)]
                  private iterable $products,
              ) {}
          }

          class Product { /* */ }
          $db = ...;

          $callback = function() use ($db) {
              $result = $db->query("SELECT name, color, price FROM products ORDER BY name");

              foreach ($result as $record) {
                  yield new Product(...$record);
              }
          };
        </code></pre>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers>
          // This is a lazy list of products, which will be pulled from the database.
          $products = new ProductList($callback());

          $s = new SerdeCommon(formatters: [new CsvStreamFormatter()]);

          // Write to stdout, aka, back to the browser.
          $init = new FormatterStream(fopen('php://output', 'wb'));
          $result = $serde->serialize($products, format: 'csv-stream', init: $init);
        </code></pre>
      </section>
      <section>
        Do I bother with scopes?  That's 10 minutes all on its own.
      </section>
    </section>
    <section>
      <section>
        <h2>Inside Serde</h2>
      </section>
      <section>
        <h3>Architecture</h3>
        <ul>
          <li class="fragment">Stream-based (no IR)</li>
          <li class="fragment">Can build IR per-format</li>
          <li class="fragment">Almost entirely Attribute-driven</li>
          <li class="fragment">Importers / Exporters</li>
          <li class="fragment">Deformatters / Formatters</li>
          <li class="fragment">Recursive all the way down</li>
        </ul>
        <aside class="notes">
          <ul>
            <li>Importer/Deformatter interact directly to avoid IR</li>
            <li>Exporter/Formatter interact directly</li>
            <li>Importer/Exporter and Formatter/Deformatter can be same object if you want, or not.</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Setup</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers="|9-10">
          class SerdeCommon extends Serde {
              protected readonly array $exporters;
              protected readonly array $importers;
              protected readonly array $formatters;
              protected readonly array $deformatters;
              protected readonly TypeMapper $typeMapper;

              public function __construct(
                  protected readonly ClassAnalyzer $analyzer
                    = new MemoryCacheAnalyzer(new Analyzer()),
                  array $handlers = [],
                  array $formatters = [],
                  array $typeMaps = [],
              ) { ... }
          }
        </code></pre>
        <ul>
          <li>Everything is readonly</li>
          <li><code>SerdeCommon</code> is just setup; write your own!</li>
          <li>Only non-exception class <code>extends</code> in the entire system</li>
          <li class="fragment">Default dependencies</li>
        </ul>
      </section>
      <section>
        <h2>Cool PHP trick #4</h2>
        <h3>Default dependencies</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          class MyService
          {
              public function __construct(private Other $other = new Other()) {}
          }
        </code></pre>
        <ul>
          <li class="fragment">Useful when dependency is mostly a util without its own dependencies</li>
          <li class="fragment">Makes testing a lot easier</li>
          <li class="fragment">Makes one-off uses easier</li>
          <li class="fragment">For production, still DI to avoid duplication</li>
          <li class="fragment">Default <code>NullLogger</code>?</li>
        </ul>
      </section>
      <section>
        <h2>Per-run object</h2>
        <pre><code class="php font--16" data-trim data-noescape data-line-numbers="|7|9-15,20">
          public function serialize(object $object, string $format,
            mixed $init = null, array $scopes = []): mixed
          {
              $formatter = $this->formatters[$format]
                ?? throw UnsupportedFormat::create($format, Direction::Serialize);

              $classDef = $this->analyzer->analyze($object, ClassSettings::class, $scopes);

              $inner = new Serializer(
                  analyzer: $this->analyzer,
                  exporters: $this->exporters,
                  formatter: $formatter,
                  typeMapper: $this->typeMapper,
                  scopes: $scopes,
              );

              $rootField = $formatter->rootField($inner, $object::class);
              $init ??= $formatter->serializeInitialize($classDef, $rootField);

              $serializedValue = $inner->serialize($object, $init, $rootField);

              return $formatter->serializeFinalize($serializedValue, $classDef);
          }
        </code></pre>
        <aside class="notes">
          <ul>
            <li>No Reflection at runtime (assuming Analyzer is cached)</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Cool PHP trick #5</h2>
        <h3>Internal execution objects</h3>
        <pre><code class="php font--14" data-trim data-noescape data-line-numbers>
          class ThingDoer {
              public function __construct(private DepA $depA, private DepB $debB) {}

              public function run(A $paramA, B $paramB) {
                  $runner = new Runner($this->depA, $this->depB, $paramA, $paramB);
                  return $runner->run();
              }
          }

          class ThingRunner {
              public function __construct(
                public readonly DepA $depA, public readonly DepB $debB, private,
                public readonly A $a, public readonly B $b) {}

            public function run(): Result {
              // Call a dozen internal methods that all use the constructor args.
            }
          }
        </code></pre>
        <ul>
          <li class="fragment">Avoid passing values in each method every time</li>
          <li class="fragment">Fully immutable, so public properties OK!</li>
          <li class="fragment">Safe to pass <code>$this</code> around dependencies</li>
          <li class="fragment">No need to DI every separate piece separately!</li>
        </ul>
      </section>
      <section>
        <h3>Serialization overview</h3>
        <div class="mermaid">
          <pre>
            sequenceDiagram
            participant Serde
            participant Serializer
            participant Exporter
            participant Formatter
            Serde->>Formatter: initialize()
            Formatter-->>Serde: prepared value
            Serde->>Serializer: Set up
            Serde->>Serializer: serialize()
            activate Serializer
            loop For each property
              Serializer->>Exporter: call depending on type
              Exporter->>Formatter: type-specific write method
              Formatter->>Serializer: serialize() sub-value
            end
            Serializer->>Formatter: finalize()
            Serializer-->>Serde: final value
            deactivate Serializer
          </pre>
        </div>
        <aside class="notes">
          <ul>
            <li>Pass along <code>$runningValue</code></li>
            <li><code>$runningValue</code> opaque to Exporter</li>
            <li>Exporter type based on PHP type, Formatter is export type</li>
          </ul>
        </aside>
      </section>
      <section>
        <h3>Deserialization overview</h3>
        <div class="mermaid">
          <pre>
            sequenceDiagram
            participant Serde
            participant Deserializer
            participant Importer
            participant Deformatter
            Serde->>Deformatter: initialize()
            Deformatter-->>Serde: prepared source
            Serde->>Deserializer: Set up
            Serde->>Deserializer: deserialize()
            activate Deserializer
            loop For each property
              Deserializer->>Importer: call depending on type
              Importer->>Deformatter: type-specific read method
              Deformatter->>Deserializer: deserialize() sub-value
            end
            Deserializer->>Deformatter: finalize()
            Deserializer-->>Serde: final value
            deactivate Deserializer
          </pre>
        </div>
      </section>
    </section>
    <section>
      <section>
        <h2>Full circle</h2>
        <p class="fragment oversize">TYPO3 decided they liked global arrays</p>
        <p class="fragment oversize"><a href="https://github.com/Crell/Config/">Crell/Config</a></p>
        <aside class="notes">
          <ul>
            <li>TYPO3 changed their mind, so I built it myself</li>
            <li>With most of the work in Serde and AttributeUtils, < 4 hours work</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Overview</h2>
        <pre><code class="yaml font--18" data-trim data-noescape data-line-numbers>
          # config/common/editorsettings.yaml
          color: "#ccddee"
          bgcolor: "#ffffff"
        </code></pre>
        <pre><code class="yaml font--18" data-trim data-noescape data-line-numbers>
          # config/dev/editorsettings.yaml
          bgcolor: '#eeff00'
        </code></pre>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          class EditorSettings {
              public function __construct(
                  public readonly string $color,
                  public readonly string $bgcolor,
                  public readonly int $fontSize = 14,
              ) {}
          }

          $loader = new LayeredLoader([
            new YamlFileSource('./config/common'),
            new YamlFileSource('./config/' . APP_ENV),
          ]);

          $editorConfig = $loader->load(EditorSettings::class);
        </code></pre>
        <aside class="notes">
          <ul>
            <li>Names, types, defaults all driven by PHP code!</li>
            <li>No custom schema format: PHP is the schema</li>
            <li>Main take away today: PHP (with attributes) is the schema.</li>
            <li>LayeredLoader auto-creates missing Serde, but accepts DI</li>
            <li>All the power of Serde for mutating on import</li>
          </ul>
        </aside>
      </section>
      <section>
        <h2>Custom naming</h2>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          use Crell\Config\Config;

          #[Config(key: 'editor_settings')]
          class EditorSettings {
              public function __construct(
                  public readonly string $color,
                  public readonly string $bgcolor,
                  public readonly int $fontSize = 14,
              ) {}
          }
        </code></pre>
        <p>Now looks for <code>editor_settings.[yaml|json|php|ini]</code></p>
        <p class="fragment">Default is <code>str_replace($class, '\', '_')</code></p>
      </section>
      <section>
        <h3>Use it</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
        class EditorForm {
            public function __construct(private EditorSettings $settings) {}

            public function renderForm(): string {
                // Do stuff here.
                $this->settings->color;
                // ...
            }
        }
        </code></pre>
        <h3>Test it</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
        class EditorFormTest extends TestCase {
            public function test_something(): void {
                $settings = new EditorSettings(color: '#fff', bgcolor: '#000');
                $subject = new EditorForm($settings);
                // Make various assertions.
            }
        }
        </code></pre>
        <h3>Dependency Inject it</h3>
        <pre><code class="php font--18" data-trim data-noescape data-line-numbers>
          $container->register(EditorSettings::class, fn(Container $c)
            => $c->get(ConfigLoader::class)->load(EditorSettings::class);
        </code></pre>
      </section>
    </section>
    <section>
      <h2>Conclusions</h2>
      <ul>
        <li class="fragment"><code>var_dump()</code> for code generating arrays only</li>
        <li class="fragment"><code>serialize()</code>/<code>unserialize()</code> for internal use</li>
        <li class="fragment">Serde for anything external</li>
        <li class="fragment">Only ever serialize value objects / clean entities</li>
        <li class="fragment">Attributes are awesome</li>
        <li class="fragment"><em>PHP is the schema</em></li>
        <li class="fragment">Holy crap modern PHP is nice!</li>
      </ul>
    </section>
    <section>
      <h2>Resources</h2>
      <div class="layout-col">
        <div>
          <h3>Libraries</h3>
          <ul>
            <li><a href="http://github.com/Crell/fp">Crell/fp</a></li>
            <li><a href="http://github.com/Crell/AttributeUtils">Crell/AttributeUtils</a></li>
            <li><a href="http://github.com/Crell/Serde">Crell/Serde</a></li>
            <li><a href="http://github.com/Crell/EnvMapper">Crell/EnvMapper</a></li>
            <li><a href="http://github.com/Crell/Config">Crell/Config</a></li>
          </ul>
        </div>
        <div>
          <h3>Articles</h3>
          <ul>
            <li><a href="https://peakd.com/hive-168588/@crell/benchmarking-serialization">Benchmarking Serialization</a></li>
            <li><a href="https://peakd.com/hive-168588/@crell/much-ado-about-null">Much Ado about Null</a></li>
          </ul>
        </div>
      </div>
    </section>

    <div style="display: none">
      * What is serialization?
        * Putting cornflakes in milk.  (Photo)
        * Definition: make a sequence, in a line.
        * Definition from Wikipedia.
      * Plethora of potential PHP processes
      * Built-ins
        * Mention old stuff, Serializable and __wakeup()
        * __serialize/__unserialize
        * var_export()
        * Benchmarks
        * Conclusion: If you want internal-only serialization, serialize() still wins.
      * What should you serialize?
        * Data objects
        * No service objects
        * Data objects with service object dependency are not data objects.
          * All the ways around this problem suck/involve globals.
      * Custom serialization
        * At TYPO3, fall 2021, wanted to turn massive config arrays into class readonly objects.
        * "Don't solve a problem, build a tool to solve the problem, then use it."
        * Needed flatten/collect, dynamic type map, high performance.
        * Tried Symfony Serializer...  way too convoluted, didn't have flatten/collect or dynamic type map.
        * Time to write one...
      * A trivial deserializer - EnvMapper
      * Crell/Serde - 8.1 before it was even out
        * Entirely attribute driven
        * AttributeUtils
        * Crell/fp - FP tools, used extensively.
        * Goal is to showcase what goes into serialization, and the power of PHP 8.1.
          * Not just showing off.
      * Deep dive - Attribute Utils
        * Incorporate reflection
        * Interface-driven functionality
        * Class-at-a-time
        * Include/exclude/Excludable
        * Inheritance!  Including interfaces!
        * Sub-attributes
        * Cache-friendly
        * Multi-step construction - SA tools, you're wrong about readonly.
        * Scopes (for serialization groups)
      * Deep dive - Serde
        * Constructor default value objects.
        * $propReader/$propWriter, to bypass visibility.
        * Enum as default object instances (renaming)
        * Recursive walk, to support streaming formats
        * Enum error codes
        * Sequence vs Dict
          * Implode
        * Iterables
          * Include example of DB->JSON streaming.
        * TypeMaps
        * Flatten/collect
        * Scopes
      * Notice... everything is immutable. Everything.  It can be done.
      * Showcase: Crell/Config.  What I wanted to build in the first place.
      * TYPO3... ended up not using it.  But yay Free Software, you can!
      * Recap
        * If it's just for internal use, serialize() still wins.
        * Separate data and logic
        * Attributes are frickin' awesome, especially with an improved parser (AttributeUtils)
        * PHP 8.x rocks.
        * It's helpful to periodically burn it down and start over... in small pieces.  (Component design!)
        * For the most robust serialization/deserialization, use Serde.
        * For the most easy to use ser/de, use Serde.
        * Hooray Free Software!


    </div>

    <section id="final">
      <div class="layout-1up-2down">
        <div style="grid-area: top; margin-top: 1em;">
          <h2>Larry Garfield</h2>
          <h2><a href="https://phpc.social/@Crell">@Crell@phpc.social</a></h2>
        </div>
        <div style="grid-area: left">
          <h2>All about PHP 8!</h2>
          <p><a href="https://bit.ly/php80">https://bit.ly/php80</a></p>
          <p><a href="https://bit.ly/php80"><img src="assets/exploring-php80.png" width="175px;" alt="Cover of Exploring PHP 8.0" /></a></p>
        </div>
        <div style="grid-area: right">
          <h2>Buy my book!</h2>
          <p><a href="https://bit.ly/fn-php">https://bit.ly/fn-php</a></p>
          <p><a href="https://bit.ly/fn-php"><img src="assets/thinking-functionally.png" width="175px;" alt="Cover of Thinking Functionally in PHP" /></a></p>
        </div>
      </div>
      <h3><a href="https://www.garfieldtech.com/">https://www.garfieldtech.com/</a></h3>
    </section>
  </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reveal.js-mermaid-plugin@2.0.0/plugin/mermaid/mermaid.js"></script>

<script>
  // More info about initialization & config:
  // - https://revealjs.com/initialization/
  // - https://revealjs.com/config/
  Reveal.initialize({
    hash: true,

    // mermaid initialize config
    mermaid: {
       flowchart: {
         curve: 'linear',
       },
    },

    // Learn about plugins: https://revealjs.com/plugins/
    plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMermaid ]
  });
</script>

<!-- Custom Reveal extension scripts. -->
<script src="platform/classer.js"></script>
<script src="platform/countup.js"></script>
<script src="platform/usecase.js"></script>

</body>
</html>
